## 객체 지향 프로그래밍
- 프로그래밍 방식은 크게 `절차 지향 프로그래밍`과 `객체 지향 프로그래밍`으로 나뉜다

### 절차 지향 프로그래밍
- 실행 순서를 중요하게 생각하는 방식
- 흐름을 순차적으로 따르며 처리한다
- `어떻게`를 중심으로 프로그래밍

### 객체 지향 프로그래밍
- 객체를 중요하게 생각하는 방식
- 객체들 간의 상호작용을 중심으로 프로그래밍
- `무엇을`을 중심으로 프로그래밍

>`절차 지향`은 데이터와 데이터에 대한 처리 방식이 분리되어 있다  
>`객체 지향`은 데이터와 메서드가 하나의 객체 안에 포함되어 있다

### 속성과 기능
- 모든 데이터를 단순하게 추상화한다면 속성(데이터)와 기능으로 분류할 수 있다
1. 자동차  
  속성: 차량 색상, 현재 속도, 브랜드, 차량 이름  
  기능: 엑셀, 브레이크, 시동 걸기, 문 열기   
2. 동물  
  속성: 크기, 체온, 이름, 먹이  
  기능: 먹기, 걷기, 뛰기, 자기
  ---

### 캡슐화
- `속성` 데이터와 `메서드` 기능을 `Class`에서 하나의 단위로 묶어서 활용한다

```Java
public class MusicPlayer {
    int volume = 0;
    boolean isOn = false; // 속성

    void on() {
        isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
    } // 기능
    void off() {
        isOn = false;
        System.out.println("음악 플레이어를 종료합니다");
    } // 기능
```
>외부의 코드가 내부의 작동 방식을 고려하지 않고 내부 실제 구현을 외부에 숨긴다.(접근 제어자)


### 생성자
- 객체를 생성함과 동시에 기능을 수행시킬 수 있게 함
1. 생성자 작성
```Java
public class MemberConsturct {
    String name;
    int age;
    int grade;
    // 생성자 부분
    MemberConsturct(String name, int age, int grade){
        System.out.println("생성자 호출 name = " + name + ", age = " + age + ", grade = " + grade);
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
```
>생성자는 `Class` 이름과 같게 생성하며 반환 타입이 없다
2. 생성자 호출
```Java
public class ConsturctMain1 {
    public static void main(String[] args) {
        MemberConsturct member1 = new MemberConsturct("user1", 16, 90); // 생성자를 통해서 선언
    }
}
```
>생성자는 인스턴스를 생성하고 나면 즉시 호출된다  
>`new` 명령어 다음에 생성자 이름과 매개변수에 맞추어 인수를 전달하면 된다

- 호출을 생성자를 이용하여 한 번에 처리가 가능하다
- 생성자 호출을 누락시킨 상태로 시스템이 작동하는 것을 방지한다

3. 기본 생성자  
 - `Class`에 생성자가 없으면 `Java`는 기본 생성자를 만든다.
 - 만들어진 생성자가 한 개라도 있다면, 기본 생성자는 만들어지지 않는다.

>생성자도 메서드 오버로딩처럼 사용이 가능하다

---

### 상속
- 클래스를 상속받아 만들어진 기능을 재활용하여 확장
- 속성과 기능을 공유
- 독자적인 동작 구현, 확장성 증진
- `has-a` 형식으로 클래스의 코드를 상속하여 활용
- `extends <클래스명>`

### 다형성
- 서로 다른 객체가 하나의 공통된 클래스 형태로 취급
- 메서드 오버로딩
>같은 이름의 메서드로 여러 기능 활용
- 메서드 오버라이딩 `@Override`
>같은 메서드가 어떤 객체가 사용하느냐에 따라 기능 변경
```
서브 클래스에서 변경하고 싶은 슈퍼 클래스와 동일한 이름의 메서드를 만들면 `오버라이딩`이 가능
```

### 추상화
- 실제 기능이 만들어지지 않은 추상 클래스를 바탕으로 기능을 위임
- 개별적 기능을 분리
- `interface` 키워드를 사용하여 기능 구현 인터페이스 정의 가능

## Object 클래스
- Java의 모든 클래스는 Object를 상속받는다.
